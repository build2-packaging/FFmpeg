define json: file
json{*}: extension = json

define asm: file
asm{*}: extension = asm

define rc: file
rc{*}: extension = rc

define res: file
res{*}: extension = res

asm_format = [string_map]    \
  'linux-gnu-x86_64'@elf64   \
  'linux-gnu-i686'@elf32     \
  'linux-musl-x86_64'@elf64  \
  'linux-musl-i686'@elf32    \
  'linux-gnu-elbrus'@elf64   \
  'win32-msvc-x86_64'@win64  \
  'win32-msvc-i686'@win32    \
  'mingw32-x86_64'@win64     \
  'mingw32-i686'@win32       \
  'darwin-x86_64'@macho64    \
  'darwin-i686'@macho32      \
  'freebsd-x86_64'@elf64     \
  'freebsd-i686'@elf32       \
  'netbsd-x86_64'@elf64      \
  'netbsd-i686'@elf32        \
  'openbsd-x86_64'@elf64     \
  'openbsd-i686'@elf32       \
  'solaris-x86_64'@elf64     \
  'solaris-i686'@elf32

rc_target = [string_map]                \
  'win32-msvc-x86_64'@pe-x86-64         \
  'win32-msvc-i386'@pe-i386             \
  'mingw32-x86_64'@pe-x86-64            \
  'mingw32-i686'@pe-i386                \
  'linux-gnu-x86_64-elf64'@elf64-x86-64 \
  'linux-gnu-i386-elf32'@elf32-i386     \
  'linux-musl-x86_64'@elf64-x86-64      \
  'linux-musl-i686'@elf32-i386          \
  'linux-iamcu-elf32'@elf32-iamcu
  # 'generic-pdb'@pdb                   \
  # 'generic-elf64-little'@elf64-little \
  # 'generic-elf64-big'@elf64-big       \
  # 'generic-elf32-little'@elf32-little \
  # 'generic-elf32-big'@elf32-big       \
  # 'generic-srec'@srec                 \
  # 'generic-symbolsrec'@symbolsrec     \
  # 'generic-verilog'@verilog           \
  # 'generic-tekhex'@tekhex             \
  # 'generic-binary'@binary             \
  # 'generic-ihex'@ihex                 \
  # 'generic-plugin'@plugin

define [see_through] enabled_source: group
enabled_source{~'/(.+)/'}: file{~'/.*-defines/'} json{~'/.+/'}
{{
  d = [dir_path] $directory($>[0])

  # read prerequisites and determine (n)asm output
  # type (that is, obja{} if building static else objs{})
  # but also all available (autoconf) defines
  files           = $filter($<, file)
  config_defs     = ($files[0])
  json            = ($filter($<, json)[0])
  cat $path($config_defs) | \
    set -n defines [string_set]

  # append default defines (that should always be assumed '1')
  defines += [string_set] OBJS ARCH_ HAVE_ HAVE_BSF HAVE_VVC HAVE_H26X

  # iterate all files listed in *.json and filter any source
  # where the corresponding define(s) wasn't evaluated to 1.
  enabled_srcs = [paths]
  skipped_srcs = [strings]
  for pair: [json] $json.load($path($json))
    echo $member_name($pair)  | set -w groups [strings]
    echo $member_value($pair) | set -w srcs [paths]

    filtered_srcs = [paths]
    for src: [paths] $srcs
      # if in an subdir, treat first subdir as 'ARCH_<DIR>', eg. 'ARCH_ARM'
      dir = $regex.replace($directory($src), '/.*', '')
      arch_dir = $string.ucase("ARCH_$dir")
      have_dir = $string.ucase("HAVE_$dir")
      skip     = [bool] ($extension($src) == 'asm')
      for group: (!$skip ? $groups :)
        negate = [bool] $string.starts_with($group, '!')
        if($negate)
          group = $string.replace($group, '!', '')
        end

        ## check if group is enabled, either (eg.) 'HAVE_X86ASM', or for CPU specific 'ARCH_ARM':
        #  is 'group' not enabled?
        #  or is ARCH_<subdir> && HAVE_<subdir> not enabled?
        #  and check is not a negation?
        #  then skip the file.
        if ((!$defines[$group] || \
            (!$defines[$arch_dir] && !$defines[$have_dir])) && \
            !$negate)
          skip = true
          skipped_srcs += "$src-\(!$arch_dir && !$have_dir \(group: $group, negate: $negate))"
        end
      end

      # append if all checks passed
      if (!$skip)
        filtered_srcs += $project/$src
      end
    end

    if (!$empty($filtered_srcs))
      enabled_srcs += [paths] $filtered_srcs
    end
  end

  # add any header prerequisites so they also get
  # symlinked (to allow relative inclusion)
  for h : $path($filter($<, h))
    if ($sub_path($h, $src_base))
      src = [path] $relative($h, $src_base)
      enabled_srcs += [paths] $src
    end
  end

  depdb dyndep \
    --dyn-target \
    --target-cwd $d \
    --target-what 'enabled source' \
    --format lines \
    -- echo $regex.merge($enabled_srcs, '(.*)', '\1', "$\n")

  diag enabled_src $>

  echo $regex.merge($skipped_srcs, '(.*)', '\1', "$\n") >!

  # symlink enabled source to out dir
  for f : [paths] $path($filter_out($>, group))
    s = [path] $src_base/$relative($f, $out_base)
    d = [path] $f
    mkdir --no-cleanup --parents $directory($d)
    ln --symbolic $s $d 2>! || true # re-creating symlink will trigger rebuild
  end
}}

define [see_through] enabled_asm: group
enabled_asm{~'/(.+)/'}: file{~'/.*-defines/'} json{~'/.+/'}
{{
  d = [dir_path] $directory($>[0])

  # read prerequisites and determine (n)asm output
  # type (that is, obja{} if building static else objs{})
  # but also all available (autoconf) defines
  files           = $filter($<, file)
  config_defs     = ($files[0])
  uameta          = ($filter($<, libua)[0])
  usmeta          = ($filter($<, libus)[0])
  meta            = (!$null($uameta) ? $uameta : $usmeta)
  json            = ($filter($<, json)[0])
  config_asm      = [path] $regex.filter_search($path($files), '.+config\.asm')
  target_type     = ($is_a($meta, libua) ? obja : objs)
  cat $path($config_defs) | \
    set -n defines [string_set]

  lib_poptions = $c.lib_poptions($meta) $c.poptions
  depdb hash $lib_poptions

  # append default defines (that should always be assumed '1')
  defines += [string_set] OBJS ARCH_ HAVE_ HAVE_BSF HAVE_VVC HAVE_H26X

  # iterate all files listed in *.json and filter any asm
  # where the corresponding define(s) wasn't evaluated to 1.
  enabled_srcs = [paths]
  skipped_srcs = [strings]
  for pair: [json] $json.load($path($json))
    echo $member_name($pair)  | set -w groups [strings]
    echo $member_value($pair) | set -w srcs [paths]

    filtered_srcs = [paths]
    for src: [paths] $srcs
      # if in an subdir, treat first subdir as 'ARCH_<DIR>', eg. 'ARCH_ARM'
      dir = $regex.replace($directory($src), '/.*', '')
      arch_dir = $string.ucase("ARCH_$dir")
      have_dir = $string.ucase("HAVE_$dir")
      skip     = [bool] ($extension($src) != 'asm')
      for group: (!$skip ? $groups :)
        negate = [bool] $string.starts_with($group, '!')
        if($negate)
          group = $string.replace($group, '!', '')
        end

        ## check if group is enabled, either (eg.) 'HAVE_X86ASM', or for CPU specific 'ARCH_ARM':
        #  is 'group' not enabled?
        #  or is ARCH_<subdir> && HAVE_<subdir> not enabled?
        #  and check is not a negation?
        #  then skip the file.
        if ((!$defines[$group] || \
            (!$defines[$arch_dir] && !$defines[$have_dir])) && \
            !$negate)
          skip = true
          skipped_srcs += "$src-\(!$arch_dir && !$have_dir \(group: $group, negate: $negate))"
        end
      end

      # append if all checks passed
      if (!$skip)
        filtered_srcs += $project/$(src).$target_type
      end
    end

    if (!$empty($filtered_srcs))
      enabled_srcs += [paths] $filtered_srcs
    end
  end

  # dummy in case target as no asm prerequisites
  dummy = [path] $out_base/enabled_asm-$(target_type).dummy

  depdb dyndep \
    --dyn-target \
    --target-cwd $d \
    --target-what 'enabled source' \
    --target-extension-type "obja=obja" \
    --target-extension-type "objs=objs" \
    --format lines \
    -- echo $regex.merge($enabled_srcs $dummy, '(.*)', '\1', "$\n")

  diag enabled_asm $>

  echo $regex.merge($skipped_srcs, '(.*)', '\1', "$\n") >!

  touch $dummy

  # compile assembly
  key = [string] "$c.target.system-$c.target.cpu"
  format = [string] ($asm_format[$key])
  for f : [paths] $path($filter($>, $target_type))
    s = [path] $src_base/$relative($f, $out_base)
    d = [path] $f
    # note: use $base() to strip target type extension
    #       from input source path.
    nasm -f $format "-P$path($config_asm)" \
         $poptions \
         $lib_poptions \
         -o $d $base($s)
  end
}}

define [see_through] adhoc_source: group
adhoc_source{~'/(.+)/'}:
{{
  d  = [dir_path] $directory($>[0])
  in = [paths] $relative($path($<), $src_base)

  depdb dyndep \
    --dyn-target \
    --target-cwd $d \
    --target-what 'adhoc' \
    --adhoc \
    --drop-cycles \
    --format lines \
    -- echo $regex.merge($in, '(.*)', '\1', "$\n")

  diag adhoc_src $>

  for f : [paths] $path($filter_out($>, group))
    s = [path] $src_base/$relative($f, $out_base)
    d = [path] $f
    mkdir --no-cleanup --parents $directory($d)
    ln --symbolic $s $d 2>! || true # re-creating symlink will trigger rebuild
  end
}}

define [see_through] winres: group
winres{~'/(.+)/'}: rc{~'/.+/'} libus{~'/\1-meta/'}
{{
  d    = [dir_path] $directory($>[0])
  rc   = $filter($<, rc)
  meta = ($filter($<, libus)[0])

  lib_poptions = $c.lib_poptions($meta, obja)
  depdb hash $lib_poptions

  inputs = [paths] $relative($path($rc), $src_base)
  depdb dyndep \
    --dyn-target \
    --target-cwd $d \
    --target-what 'resource' \
    --format lines \
    -- echo $regex.merge($inputs, '(.*)\.rc', '\1.res', "$\n")

  diag rc $rc -> $filter_out($>, group)

  for src : [paths] $path($rc)
    dst = [path] $out_base/$base($relative($src, $src_base)).res
    mkdir --parents $directory($dst)
    rc.exe /nologo \
           $regex.apply($c.poptions, '\\', '/') \
           $regex.apply($lib_poptions, '\\', '/') \
           /fo $dst $src
  end
}}
